<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta charset="UTF-8">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
        <link rel="stylesheet" href="/technical-documentation-page/style.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
        <script src="/technical-documentation-page/script.js"></script>
    </head>

    <body>
        <div id="navbar" class="sidenav tab-menu">
            <header>JQuery</header>
              <span class="closebtn" onclick="closeNav()">&times;</span>
        
          <a href="#link1" class="nav-link current">About JQuery</a>
          <a href="#link2" class="nav-link">How JQuery Works</a>
          <a href="#link3" class="nav-link">$ and $()</a>
          <a href="#link4" class="nav-link">$(document).ready()</a>
            <a href="#link5" class="nav-link">Avoiding Conflicts With Other Libraries</a>
            <a href="#link6" class="nav-link">Attributes</a>
            <a href="#link7" class="nav-link">Selecting Elements</a>
            <a href="#link8" class="nav-link">Working With Selections</a>
            <a href="#link9" class="nav-link">Manipulating Elements</a>
            <a href="#link10" class="nav-link">The Jquery Object</a>
            <a href="#link11" class="nav-link">Traversing</a>
            <a href="#link12" class="nav-link">Css, Styling and Dimensions</a>
            <a href="#link13" class="nav-link">Data Methods</a>
            <a href="#link14" class="nav-link">Utility Methods</a>
            <a href="#link15" class="nav-link">Iterating Over JQuery and non-jquery Objects</a>
            <a href="#link16" class="nav-link">Using JQuery's .index() Function</a>
        </div>
        
        <div id="main">
          
          <span class="openbtn" onclick="openNav()">&#9776; </span>
            
            
            <div class="head">
                <h1>JQUERY DOCUMENTATİON</h1>
            </div>
        
        <section>
            
            <article class="tab-content" id="link1">
                  <h3>About JQuery</h3>
            <p>Getting started with jQuery can be easy or challenging, depending on your experience with JavaScript, HTML, CSS, and programming concepts in general.</p>
            <p>One important thing to know is that jQuery is just a JavaScript library. All the power of jQuery is accessed via JavaScript, so having a strong grasp of JavaScript is essential for understanding, structuring, and debugging your code. While working with jQuery regularly can, over time, improve your proficiency with JavaScript, it can be hard to get started writing jQuery without a working knowledge of JavaScript's built-in constructs and syntax.</p>
            </article>
        
        </section>
        
        
        <section>
                <article class="tab-content" id="link2">
                         <h3>How JQuery Works</h3>
            <h4>Link Launching Code on Document Ready</h4>
            <p>To ensure that their code runs after the browser finishes loading the document, many JavaScript programmers wrap their code in an onload function:</p>
            <code>
            window.onload = function() {
         <br>
            alert( "welcome" );
         <br>
            };
            </code>
        <p>Unfortunately, the code doesn't run until all images are finished downloading, including banner ads.</p>
            <code>
              $( document ).ready(function() {
         <br>
                    $( "a" ).click(function( event ) {
         <br>
              alert( "Thanks for visiting!" );
         <br>
            });
         <br>
            });
            </code>
            
            <p>For click and most other events, you can prevent the default behavior by calling <b>event.preventDefault()</b> in the event handler:
        </p>
          <code>
            $( document ).ready(function() {
         <br>
            $( "a" ).click(function( event ) {
         <br>
            alert( "As you can see, the link no longer took you to jquery.com" );
         <br>
            event.preventDefault();
         <br>
            });
         <br>
            });
            </code>
            </article>
        </section>
        
              <section>
            <article id="link3" class="tab-content">
                <h3>$ and $()</h3>
                <code>$( "h1" ).remove();</code>
                <p>Most jQuery methods are called on jQuery objects as shown above; these methods are said to be part of the <b>$.fn</b> namespace, or the "jQuery prototype," and are best thought of as jQuery object methods.
        </p>
                <p>However, there are several methods that do not act on a selection; these methods are said to be part of the jQuery namespace, and are best thought of as core jQuery methods.</p>
              <p>This distinction can be incredibly confusing to new jQuery users. Here's what you need to remember:</p>
        <ul>
        <li>Methods called on jQuery selections are in the <b>$.fn</b> namespace, and automatically receive and return the selection as <b>this</b>.</li>
          <li>
        Methods in the <b>$</b> namespace are generally utility-type methods, and do not work with selections; they are not automatically passed any arguments, and their return value will vary.</li>
          </ul>  
              <p>There are a few cases where object methods and core methods have the same names, such as <b>$.each()</b> and <b>.each()</b>. In these cases, be extremely careful when reading the documentation that you are exploring the correct method.</p>
          </article>
          </section>
        
            <section>
                 <article id="link4" class="tab-content">
            <h3>$(document).ready()</h3>
             <p>A page can't be manipulated safely until the document is "ready." jQuery detects this state of readiness for you. Code included inside <b>$( document ).ready()</b> will only run once the page Document Object Model (DOM) is ready for JavaScript code to execute. Code included inside <b>$( window ).on( "load", function() { ... })</b> will run once the entire page (images or iframes), not just the DOM, is ready.</p>
             <p>You can also pass a named function to <b>$( document ).ready()</b> instead of passing an anonymous function.</p>
             <code>
               // Passing a named function instead of an anonymous function.
         <br>
              function readyFn( jQuery ) {
           <br>
                                // Code to run when the document is ready.
            <br>
                                }
         <br>
              $( document ).ready( readyFn );
          <br>
                                // or:
           <br>
                                $( window ).on( "load", readyFn );
               </code>
            </article>
            </section>
            
              <section>
           <article id="link5" class="tab-content">
             <h3>Avoiding Conflicts with Other Libraries</h3>
             <p>The jQuery library and virtually all of its plugins are contained within the <b>jQuery</b> namespace. As a general rule, global objects are stored inside the jQuery namespace as well, so you shouldn't get a clash between jQuery and any other library (like prototype.js, MooTools, or YUI).</p>
             <p>That said, there is one caveat: <i>by default, jQuery uses <b>$</b> as a shortcut for <b>jQuery</b></i>. Thus, if you are using another JavaScript library that uses the <b>$</b> variable, you can run into conflicts with jQuery. In order to avoid these conflicts, you need to put jQuery in no-conflict mode immediately after it is loaded onto the page and before you attempt to use jQuery in your page.</p>
             <h4>Putting jQuery Into No-Conflict Mode</h4>
             <p>When you put jQuery into no-conflict mode, you have the option of assigning a new variable name to replace the <b>$</b> alias.</p>
           <code>
          var $j = jQuery.noConflict();
          <br>
                // $j is now an alias to the jQuery function; creating the new alias is optional.
         <br>
           $j(document).ready(function() {
          <br>
                        $j( "div" ).hide();
           <br>
                        });
         <br>
            // The $ variable now has the prototype meaning, which is a shortcut for
          <br>
                        // document.getElementById(). mainDiv below is a DOM element, not a jQuery object.
           <br>
                        window.onload = function() {
            <br>
                        var mainDiv = $( "main" );
            <br>
                        }
             </code>
            <p>In the code above, the <b>$</b> will revert back to its meaning in original library. You'll still be able to use the full function name <b>jQuery</b> as well as the new alias <b>$j</b> in the rest of your application. The new alias can be named anything you'd like: <b>jq</b>, <b>$J</b>, <b>awesomeQuery</b>, etc.</p>
             <h4>Including jQuery Before Other Libraries</h4>
             <p>The code snippets above rely on <b>jQuery</b> being loaded after prototype.js is loaded. If you include jQuery before other libraries, you may use <b>jQuery</b> when you do some work with jQuery, but the <b>$</b> will have the meaning defined in the other library. There is no need to relinquish the <b>$</b> alias by calling <b>jQuery.noConflict()</b>.</p>
            </article>
            </section>
            
            
             <section>
           <article id="link6" class="tab-content">
              <h3>Attributes</h3>
             <h4>The .attr() Method</h4>
             <p>The <b>.attr()</b> method acts as both a getter and a setter. As a setter, <b>.attr()</b> can accept either a key and a value, or an object containing one or more key/value pairs.</p>
             <p><b>.attr()</b> as a setter:</p>
             <code>
               $( "a" ).attr( "href", 
                                <br>
                                "allMyHrefsAreTheSameNow.html" );
         <br>
                $( "a" ).attr({
            <br>
                                title: "all titles are the same too!",
            <br>
                                href: "somethingNew.html"
             <br>
                                });
              </code>
             <p><b>.attr()</b> as a getter:</p>
             <code>
               $( "a" ).attr( "href" ); // Returns the href for the first a element in the document
              </code>
            </article>
            </section>
            
              <section>
              <article id="link7" class="tab-content">
                <h3>Selecting Elements</h3>
                <h4>Selecting Elements by ID</h4>
                <code>
         $( "#myId" ); // Note IDs must be unique per page.
                 </code>
          <h4>Selecting Elements by Class Name</h4>
                <code>
                  $( ".myClass" );
                </code>
          <h4> Selecting Elements by Attribute</h4>
                <code>
                  $( "input[name='first_name']" );
                 </code>
        <h4>Selecting Elements by Compound CSS Selector</h4>
            <code>
              $( "#contents ul.people li" );
             </code>
        <h4>Selecting Elements with a Comma-separated List of Selectors</h4>
        <code>
              $( "div.myClass, ul.people" );
          </code>
         <h4>Pseudo-Selectors</h4>
                <code>
           $( "a.external:first" );
           <br>     
                $( "tr:odd" );
         <br>
          // Select all input-like elements in a form (more on this below).
          <br>
                    $( "#myForm :input" );
           <br>     
            $( "div:visible" );
         <br>
          // All except the first three divs.
          <br>      
        $( "div:gt(2)" );
         <br>
         // All currently animated divs.
         <br> 
            $( "div:animated" );
                  </code>
            <p><b>Note:</b> When using the <b>:visible</b> and <b>:hidden</b> pseudo-selectors, jQuery tests the actual visibility of the element, not its CSS <b>visibility</b> or <b>display</b> properties. jQuery looks to see if the element's physical height and width on the page are both greater than zero.</p>
                <p>Elements that have not been added to the DOM will always be considered hidden, even if the CSS that would affect them would render them visible. See the Manipulating Elements section to learn how to create and add elements to the DOM.</p>
              <h4>Choosing Selectors</h4>
                <p>Choosing good selectors is one way to improve JavaScript's performance. Too much specificity can be a bad thing. A selector such as <b>#myTable thead tr th.special</b> is overkill if a selector such as <b>#myTable th.special</b> will get the job done.</p>
                <p>Once you've made a selection, you'll often want to know whether you have anything to work with. A common mistake is to use:</p>
                <code>
                  // Doesn't work!
                 <br>
                                            if ( $( "div.foo" ) ) {
                 <br> 
                                            ...
                 <br> 
                                            }
                  </code>
                <p>This won't work. When a selection is made using <b>$()</b>, an object is always returned, and objects always evaluate to <b>true</b>. Even if the selection doesn't contain any elements, the code inside the <b>if</b> statement will still run.</p>
                <p>The best way to determine if there are any elements is to test the selection's <b>.length</b> property, which tells you how many elements were selected. If the answer is 0, the <b>.length</b> property will evaluate to <b>false</b> when used as a boolean value:</p>
                <code>
           // Testing whether a selection contains elements.
           <br>       
                    if ( $( "div.foo" ).length ) {
           <br>      
                    ...
           <br>       
                    }
               </code>
                <h4>Saving Selections</h4>
           <p> jQuery doesn't cache elements for you. If you've made a selection that you might need to make again, you should save the selection in a variable rather than making the selection repeatedly.</p>
                <code>
                  var divs = $( "div" );
                </code>
            <p>Once the selection is stored in a variable, you can call jQuery methods on the variable just like you would have called them on the original selection.</p>
            <p>A selection only fetches the elements that are on the page at the time the selection is made. If elements are added to the page later, you'll have to repeat the selection or otherwise add them to the selection stored in the variable. Stored selections don't magically update when the DOM changes.</p>
           <h4>Refining and Filtering Selections</h4>
        <p>Sometimes the selection contains more than what you're after. jQuery offers several methods for refining and filtering selections.</p>
                <code>
         // Refining selections.
        <br>
        $( "div.foo" ).has( "p" ); // div.foo elements that contain p tags
        <br>
        $( "h1" ).not( ".bar" ); // h1 elements that don't have a class of bar
        <br>
        $( "ul li" ).filter( ".current" ); // unordered list items with class of current
        <br>
        $( "ul li" ).first(); // just the first unordered list item
        <br>
        $( "ul li" ).eq( 5 ); // the sixth
                </code>
        <h4>Selecting Form Elements</h4>
          <p>jQuery offers several pseudo-selectors that help find elements in forms. These are especially helpful because it can be difficult to distinguish between form elements based on their state or type using standard CSS selectors.</p>
            <code>
              $( "form :checked" ); <br>
              $( "form :disabled" ); <br>
              $( "form :enabled" ); <br>
              $( "form :input" ); <br>
              $( "form :selected" ); <br>
            </code>
                </article>
              </section>
        
            <section>
          <article id="link8" class="tab-content">
         <h3> Working with Selections</h3>
            <h4>Link Getters And Setters</h4>
        <p>Some jQuery methods can be used to either assign or read some value on a selection. When the method is called with a value as an argument, it's referred to as a setter because it sets (or assigns) that value. When the method is called with no argument, it gets (or reads) the value of the element. Setters affect all elements in a selection, whereas getters return the requested value only for the first element in the selection, with the exception of <b>.text()</b>, which retrieves the values of all the elements.</p>
        <code>
         // The .html() method sets all the h1 elements' html to be "hello world":
         <br>  $( "h1" ).html( "hello world" );
        </code>
                    <br><br>
          <code>
         // The .html() method returns the html of the first h1 element:
         <br>     $( "h1" ).html();
           <br>   // > "hello world"
          </code>
        <p>Setters return a jQuery object, allowing you to continue calling jQuery methods on your selection. Getters return whatever they were asked to get, so you can't continue to call jQuery methods on the value returned by the getter.</p>
        <code>
              // Attempting to call a jQuery method after calling a getter. <br>
              // This will NOT work: <br>
              $( "h1" ).html().addClass( "test" );
        </code>
            <h4>Chaining</h4>
        <p>If you call a method on a selection and that method returns a jQuery object, you can continue to call jQuery methods on the object without pausing for a semicolon. This practice is referred to as "chaining":</p>
        <code>
              $( "#content" ).find( "h3" ).eq( 2 ).html( "new text for the third h3!" );
         </code>
            <p>It may help code readability to break the chain over several lines:</p>
            <code>
              $( "#content" ) <br>
              .find( "h3" ) <br>
              .eq( 2 ) <br>
              .html( "new text for the third h3!"	);
             </code>
        <p>    
        jQuery also provides the <b>.end()</b> method to get back to the original selection should you change the selection in the middle of a chain:</p>
        <code>
             $( "#content" ) <br>
             .find( "h3" ) <br>
             .eq( 2 ) <br>
             .html( "new text for the third h3!" ) <br>
             .end() // Restores the selection to all h3s in #content <br>
            .eq( 0 ) <br>
            .html( "new text for the first h3!" );
          </code>
        <p>
        Chaining is extraordinarily powerful, and it's a feature that many libraries have adapted since it was made popular by jQuery. However, it must be used with care – extensive chaining can make code extremely difficult to modify or debug. There is no hard-and-fast rule to how long a chain should be – just know that it's easy to get carried away.</p>
              </article>
            </section>
        
            <section>
          <article id="link9" class="tab-content">
            <h3>Manipulating Elements</h3>
           <h4> Getting and Setting Information About Elements</h4>
        <p>There are many ways to change an existing element. Among the most common tasks is changing the inner HTML or attribute of an element. jQuery offers simple, cross-browser methods for these sorts of manipulations. You can also get information about elements using many of the same methods in their getter incarnations. For more information on getters and setters, see the Working with Selections section. Here are a few methods you can use to get and set information about elements:</p>
            <ul>
          <li> <b>.html()</b> – Get or set the HTML contents.</li>
        <li><b>.text()</b> – Get or set the text contents; HTML will be stripped.</li>
        <li><b>.attr()</b> – Get or set the value of the provided attribute.</li>
        <li><b>.width()</b> – Get or set the width in pixels of the first element in the selection as an integer.</li>
        <li><b>.height()</b> – Get or set the height in pixels of the first element in the selection as an integer.</li>
        <li><b>.position()</b> – Get an object with position information for the first element in the selection, relative to its first positioned ancestor. This is a getter only.</li>
        <li><b>.val()</b> – Get or set the value of form elements.</li>
              </ul>
         <p>Changing things about elements is trivial, but remember that the change will affect all elements in the selection. If you just want to change one element, be sure to specify that in the selection before calling a setter method.</p>
          <h4>Moving, Copying, and Removing Elements</h4>
            <p>While there are a variety of ways to move elements around the DOM, there are generally two approaches:</p>
            <ul>
              <li>Place the selected element(s) relative to another element.</li>
              <li>Place an element relative to the selected element(s).</li>
            </ul>
            <p>For example, jQuery provides <b>.insertAfter()</b> and <b>.after()</b>. The <b>.insertAfter()</b> method places the selected element(s) after the element provided as an argument. The <b>.after()</b> method places the element provided as an argument after the selected element. Several other methods follow this pattern: <b>.insertBefore()</b> and <b>.before()</b>, <b>.appendTo()</b> and <b>.append()</b>, and <b>.prependTo()</b> and <b>.prepend()</b>.</p>
        <p>The method that makes the most sense will depend on what elements are selected, and whether you need to store a reference to the elements you're adding to the page. If you need to store a reference, you will always want to take the first approach – placing the selected elements relative to another element – as it returns the element(s) you're placing. In this case, <b>.insertAfter()</b>, <b>.insertBefore()</b>, <b>.appendTo()</b>, and <b>.prependTo()</b> should be the tools of choice.</p>
            <code>
              // Moving elements using different approaches.
        <br> <br>
             // Make the first list item the last list item:
        <br>     var li = $( "#myList li:first" ).appendTo( "#myList" );
         <br><br>
            // Another approach to the same problem:
        <br>    $( "#myList" ).append( $( "#myList li:first" ) );
         <br><br>
            // Note that there's no way to access the list item
          <br>  // that we moved, as this returns the list itself.
            </code>
        
        <h4>Cloning Elements</h4>
         <p>Methods such as <b>.appendTo()</b> move the element, but sometimes a copy of the element is needed instead. In this case, use <b>.clone()</b> first:</p>
            <code>
              // Making a copy of an element.
         <br><br>
              // Copy the first list item to the end of the list:<br>
              $( "#myList li:first" ).clone().appendTo( "#myList" );
            </code>
        <p>If you need to copy related data and events, be sure to pass <b>true</b> as an argument to <b>.clone()</b>.</p>
        <h4>Removing Elements</h4>
            <p>There are two ways to remove elements from the page: <b>.remove()</b> and <b>.detach()</b>. Use <b>.remove()</b> when you want to permanently remove the selection from the page. While <b>.remove()</b> does return the removed element(s), those elements will not have their associated data and events attached to them if you return them to the page.</p>
        <p>Use <b>.detach()</b> if you need the data and events to persist. Like <b>.remove()</b>, it returns the selection, but it also maintains the data and events associated with the selection, so you can restore the selection to the page at a later time.</p>
            <p>The <b>.detach()</b> method is extremely valuable if you are doing heavy manipulation on an element. In that case, it's beneficial to <b>.detach()</b> the element from the page, work on it in your code, then restore it to the page when you're done. This limits expensive "DOM touches" while maintaining the element's data and events.</p>
        <p>If you want to leave the element on the page but remove its contents, you can use <b>.empty()</b> to dispose of the element's inner HTML.</p>
        <h4>Creating New Elements</h4>
            <p>When you create a new element, it is not immediately added to the page. There are several ways to add an element to the page once it's been created.</p>
            <code>
              // Getting a new element on to the page.
         <br>
              myNewElement.appendTo( "#content" );
         <br>
              myNewElement.insertAfter( "ul:last" ); // This will remove the p from #content!
        <br>      $( "ul" ).last().after(                     myNewElement.clone() ); // Clone the p so now we have two.
            </code>
        <p>The created element doesn't need to be stored in a variable – you can call the method to add the element to the page directly after the <b>$()</b>. However, most of the time you'll want a reference to the element you added so you won't have to select it later.</p>
        <p>The syntax for adding new elements to the page is easy, so it's tempting to forget that there's a huge performance cost for adding to the DOM repeatedly. If you're adding many elements to the same container, you'll want to concatenate all the HTML into a single string, and then append that string to the container instead of appending the elements one at a time.</p>
            <h4>Manipulating Attributes</h4>
            <p>jQuery's attribute manipulation capabilities are extensive. Basic changes are simple, but the <b>.attr()</b> method also allows for more complex manipulations. It can either set an explicit value, or set a value using the return value of a function. When the function syntax is used, the function receives two arguments: the zero-based index of the element whose attribute is being changed, and the current value of the attribute being changed.</p>
        <code>
            // Manipulating a single attribute.
          <br>  $( "#myDiv a:first" ).attr( "href", "newDestination.html" );
            </code>
           <br><br> 
                    <code>
              // Manipulating multiple attributes.
           <br>  
                        $( "#myDiv a:first" ).attr({
           <br>  
                        href: "newDestination.html",
            <br>  
                        rel: "nofollow"
          <br>   
                        });
            </code>
                    
                    <br><br>
            <code>
         // Using a function to determine an attribute's new value.
        <br>     
                $( "#myDiv a:first" ).attr({
          <br>   
            rel: "nofollow",
         <br>    
            href: function( idx, href ) {
         <br>     
            return "/new/" + href;
         <br>    
                }
          <br>   
                    });
         <br>
              $( "#myDiv a:first" ).attr( "href", function( idx, href ) {
         <br>
                return "/new/" + href;
          <br>
                });
            </code>
          </article>
        </section>
        
            <section>
          <article id="link10" class="tab-content">
            <h3>The JQuery Object</h3>
            <p>When creating new elements (or selecting existing ones), jQuery returns the elements in a collection. Many developers new to jQuery assume that this collection is an array. It has a zero-indexed sequence of DOM elements, some familiar array functions, and a <b>.length</b> property, after all. Actually, the jQuery object is more complicated than that.</p>
            <h4>DOM and DOM Elements</h4>
            <p>The Document Object Model (DOM for short) is a representation of an HTML document. It may contain any number of DOM elements. At a high level, a DOM element can be thought of as a "piece" of a web page. It may contain text and/or other DOM elements. DOM elements are described by a type, such as <b>div</b>, <b>a</b>, or <b>p</b>, and any number of attributes such as src, href, class and so on. For a more thorough description, refer to the official DOM specification from the W3C.</p>
            <p>Elements have properties like any JavaScript object. Among these properties are attributes like <b>.tagName</b> and methods like <b>.appendChild()</b>. These properties are the only way to interact with the web page via JavaScript.</p>
            <h4>The JQuery Object</h4>
            <p>It turns out that working directly with DOM elements can be awkward. The jQuery object defines many methods to smooth out the experience for developers. Some benefits of the jQuery Object include:</p>
        <p><em>Compatibility</em> – The implementation of element methods varies across browser vendors and versions.</p>
            <p>This works in many cases, but it will fail in most versions of Internet Explorer. In that case, the recommended approach is to use pure DOM methods instead. By wrapping the <b>target</b> element in a jQuery object, these edge cases are taken care of, and the expected result is achieved in all supported browsers</p>
            <p><em>Convenience</em> – There are also a lot of common DOM manipulation use cases that are awkward to accomplish with pure DOM methods. For instance, inserting an element stored in <b>newElement</b> after the <b>target</b> element requires a rather verbose DOM method:</p>
            <code>
              // Inserting a new element after another with the native DOM API.
         <br>
              var target = document.getElementById( "target" );
         <br>
              var newElement = document.createElement( "div" );
         <br>
              target.parentNode.insertBefore( newElement, target.nextSibling );
            </code>
          <p>By wrapping the <b>target</b> element in a jQuery object, the same task becomes much simpler:</p>
            <code>
              // Inserting a new element after another with jQuery.
         <br>
              var target = document.getElementById( "target" );
         <br>
              var newElement = document.createElement( "div" );
         <br>
              $( target ).after( newElement );
            </code>
          <p>For the most part, these details are simply "gotchas" standing between you and your goals.</p>
            <h4>Getting Elements İnto The JQuery Object</h4>
            <p>When the jQuery function is invoked with a CSS selector, it will return a jQuery object wrapping any element(s) that match this selector. For instance, writing:</p>
            <code>
              // Selecting all h1 tags.
         <br>
              var headings = $( "h1" );
              </code>
          <p><b>headings</b> is now a jQuery element containing all the <b>h1</b> tags already on the page. This can be verified by inspecting the <b>.length</b> property of <b>headings</b>:</p>
           <code>
             // Viewing the number of <b>h1</b> tags on the page.
         <br>
            var headings = $( "h1" );
         <br>
            alert( headings.length );
             </code>
           <p>If the page has more than one <b>h1</b> tag, this number will be greater than one. If the page has no <b>h1</b> tags, the <b>.length</b> property will be zero. Checking the <b>.length</b> property is a common way to ensure that the selector successfully matched one or more elements.</p>
         <p>If the goal is to select only the first heading element, another step is required. There are a number of ways to accomplish this, but the most straight-forward is the <b>.eq()</b> function.</p>
            <code>
              // Selecting only the first <b>h1</b> element on the page (in a jQuery object)
         <br>
              var headings = $( "h1" );
         <br>
              var firstHeading = headings.eq( 0 );
              </code>
            <p>Now <b>firstHeading</b> is a jQuery object containing only the first <b>h1</b> element on the page. And because <b>firstHeading</b> is a jQuery object, it has useful methods like <b>.html()</b> and <b>.after()</b>. jQuery also has a method named <b>.get()</b> which provides a related function. Instead of returning a jQuery-wrapped DOM element, it returns the DOM element itself.</p>
            <code>
              // Selecting only the first <b>h1</b> element on the page.
         <br>
              var firstHeadingElem = $( "h1" ).get( 0 );
              </code>
            <p>Alternatively, because the jQuery object is "array-like," it supports array subscripting via brackets:</p>
            <code>
              // Selecting only the first <b>h1</b> element on the page (alternate approach).
         <br>
             var firstHeadingElem = $( "h1" )[ 0 ];
              </code>
            <p>In either case, <b>firstHeadingElem</b> contains the native DOM element. This means it has DOM properties like <b>.innerHTML</b> and methods like <b>.appendChild()</b>, but not jQuery methods like <b>.html()</b> or <b>.after()</b>. The <b>firstHeadingElem</b> element is more difficult to work with, but there are certain instances that require it. One such instance is making comparisons.</p>
            <h4>Not All jQuery Objects are Created ===</h4>
            <p>An important detail regarding this "wrapping" behavior is that each wrapped object is unique. This is true <em>even if the object was created with the same selector or contain references to the exact same DOM elements.</em></p>
            <code>
              // Creating two jQuery objects for the same element.
         <br>
              var logo1 = $( "#logo" );
         <br>
                            var logo2 = $( "#logo" );
            </code>
            <p>Although logo1 and logo2 are created in the same way (and wrap the same DOM element), they are not the same object.</p>
            <p>However, both objects contain the same DOM element. The <b>.get()</b> method is useful for testing if two jQuery objects have the same DOM element.</p>
            <code>
              // Comparing DOM elements.
         <br>
              var logo1 = $( "#logo" );
        <br>
                            var logo1Elem = logo1.get( 0 );
         <br>
              var logo2 = $( "#logo" );
        <br>
                            var logo2Elem = logo2.get( 0 );
         <br>
              alert( logo1Elem === logo2Elem ); // alerts "true"
              </code>
        <p>Many developers prefix a <b>$</b> to the name of variables that contain jQuery objects in order to help differentiate. There is nothing magic about this practice – it just helps some people keep track of what different variables contain. The previous example could be re-written to follow this convention:</p>
            <code>
              // Comparing DOM elements (with more readable variable names).
         <br>
              var $logo1 = $( "#logo" );
         <br>
                            var logo1 = $logo1.get( 0 );
         <br>
              var $logo2 = $( "#logo" );
        <br>
                            var logo2 = $logo2.get( 0 );
         <br>
              alert( logo1 === logo2 ); // alerts "true"
            </code>
          <p>Regardless of the naming convention used, it is very important to make the distinction between jQuery object and native DOM elements. Native DOM methods and properties are not present on the jQuery object, and vice versa. Error messages like "event.target.closest is not a function"' and "TypeError: Object [object Object] has no method 'setAttribute'" indicate the presence of this common mistake.</p>
            <h4>jQuery Objects Are Not "Live"</h4>
           <p>…one might expect that the contents will grow and shrink over time as <b>p</b> elements are added and removed from the document. jQuery objects do <b>not</b> behave in this manner. The set of elements contained within a jQuery object will not change unless explicitly modified. This means that the collection is not "live" – it does not automatically update as the document changes. If the document may have changed since the creation of the jQuery object, the collection should be updated by creating a new one. It can be as easy as re-running the same selector:</p>
           <h4> Wrapping Up</h4>
        <p>Although DOM elements provide all the functionality one needs to create interactive web pages, they can be a hassle to work with. The jQuery object wraps these elements to smooth out this experience and make common tasks easy. When creating or selecting elements with jQuery, the result will always be wrapped in a new jQuery object. If the situation calls for the native DOM elements, they may be accessed through the <b>.get()</b> method and/or array-style subscripting.</p>
          </article>
        </section>
            
            <section>
          <article id="link11" class="tab-content">
            <h3>Traversing</h3>
            <p>Once you've made an initial selection with jQuery, you can traverse deeper into what was just selected. Traversing can be broken down into three basic parts: parents, children, and siblings. jQuery has an abundance of easy-to-use methods for all these parts. Notice that each of these methods can optionally be passed string selectors, and some can also take another jQuery object in order to filter your selection down.</p>
            <code>
              // Selecting an element's direct parent:
         <br><br>
              // returns [ div.child ]
        <br>
                            $( "span.subchild" ).parent();
         <br><br>
              // Selecting all the parents of an element that match a given selector:
         <br><br>
              // returns [ div.parent ]
         <br>
                            $( "span.subchild" ).parents( "div.parent" );
         <br><br>
              // returns [ div.child, div.parent, div.grandparent ]
         <br>
                            $( "span.subchild" ).parents();
         <br><br>
              // Selecting all the parents of an element up to, but *not including* the selector:
         <br><br>
              // returns [ div.child, div.parent ]
        <br> 
                            $( "span.subchild" ).parentsUntil( "div.grandparent" );
         <br><br>
              // Selecting the closest parent, note that only one parent will be selected
          <br>
                            // and that the initial element itself is included in the search:
         <br><br>
              // returns [ div.child ]
        <br> 
                            $( "span.subchild" ).closest( "div" );
         <br><br>
              // returns [ div.child ] as the selector is also included in the search:
         <br> 
                            $( "div.child" ).closest( "div" );
              </code>
            <h4>Children</h4>
        <p>The methods for finding child elements from a selection include <b>.children()</b> and <b>.find()</b>. The difference between these methods lies in how far into the child structure the selection is made. <b>.children()</b> only operates on direct child nodes, while <b>.find()</b> can traverse recursively into children, children of those children, and so on.</p>
            <code>
              // Selecting an element's direct children:
         <br><br>
              // returns [ div.parent,                   div.surrogateParent1, div.surrogateParent2 ]
         <br>
                            $( "div.grandparent" ).children( "div" );
         <br><br>
              // Finding all elements within a selection that match the selector:
         <br><br>
              // returns [ div.child, div.parent, div.surrogateParent1, div.surrogateParent2 ]
           <br>
                            $( "div.grandparent" ).find( "div" );
              </code>
           <h4> Siblings</h4>
        <p>The rest of the traversal methods within jQuery all deal with finding sibling selections. There are a few basic methods as far as the direction of traversal is concerned. You can find previous elements with <b>.prev()</b>, next elements with <b>.next()</b>, and both with <b>.siblings()</b>. There are also a few other methods that build onto these basic methods: <b>.nextAll()</b>, <b>.nextUntil()</b>, <b>.prevAll()</b> and <b>.prevUntil()</b>.</p>
            <code>
              // Selecting a next sibling of the selectors:
         <br><br>
              // returns [ div.surrogateParent1 ]
        <br> 
                            $( "div.parent" ).next();
         <br><br>
              // Selecting a prev sibling of the selectors:
         <br><br>
              // returns [] as No sibling exists before div.parent
         <br>
                            $( "div.parent" ).prev();
         <br><br>
              // Selecting all the next siblings of the selector:
         <br><br>
              // returns [ div.surrogateParent1, div.surrogateParent2 ]
                <br>
                            $( "div.parent" ).nextAll();
         <br><br>
              // returns [ div.surrogateParent1 ]
        <br>
                            $( "div.parent" ).nextAll().first();
         <br><br>
              // returns [ div.surrogateParent2 ]
            <br>
                            $( "div.parent" ).nextAll().last();
         <br><br>
              // Selecting all the previous siblings of the selector:
         <br><br>
              // returns [ div.surrogateParent1, div.parent ]
          <br> 
                            $( "div.surrogateParent2" ).prevAll();
         <br><br>
              // returns [ div.surrogateParent1 ]               <br>    
                            $("div.surrogatePare).prevAll().first();
         <br><br>
              // returns [ div.parent ]
         <br> 
                            $( "div.surrogateParent2" ).prevAll().last();
            </code>
          <p>Use <b>.siblings()</b> to select all siblings:</p>
            <code>
              // Selecting an element's siblings in both directions that matches the given selector:
         <br><br>
              // returns [ div.surrogateParent1, div.surrogateParent2 ]
            <br>
                            $( "div.parent" ).siblings();
         <br><br>
              // returns [ div.parent, div.surrogateParent2 ]
         <br>
                            $( "div.surrogateParent1" ).siblings();
              </code>
          <p>Be cautious when traversing long distances in documents – complex traversal makes it imperative that the document's structure remain the same, which is difficult to guarantee even if you're the one creating the whole application from server to client. One- or two-step traversal is fine, but it's best to avoid traversals that go from one container to another.</p>
            
          </article>
        </section>
        
            <section>
          <article id="link12" class="tab-content">
            <h3>CSS, Styling, And Dimensions</h3>
            <p>jQuery includes a handy way to get and set CSS properties of elements:</p>
            <code>
              // Getting CSS properties.
         <br>
              $( "h1" ).css( "fontSize" ); // Returns a string such as "19px".
         <br>
              $( "h1" ).css( "font-size" ); // Also works.
              </code>
            <code>
              // Setting CSS properties.
         <br>
              $( "h1" ).css( "fontSize", "100px" );  // Setting an individual property.
         <br>
              // Setting multiple properties.
              $( "h1" ).css({ <br>
              fontSize: "100px", <br>
              color: "red" <br>
              });
              </code>
            <p>Note the style of the argument on the second line – it is an object that contains multiple properties. This is a common way to pass multiple arguments to a function, and many jQuery setter methods accept objects to set multiple values at once.</p>
            <p>CSS properties that normally include a hyphen need to be camelCased in JavaScript. For example, the CSS property <b>font-size</b> is expressed as <b>fontSize</b> when used as a property name in JavaScript. However, this does not apply when passing the name of a CSS property to the <b>.css()</b> method as a string – in that case, either the camelCased or hyphenated form will work.</p>
            <p>It's not recommended to use .css() as a setter in production-ready code, but when passing in an object to set CSS, CSS properties will be camelCased instead of using a hyphen.</p>
          <h4>Using CSS Classes for Styling</h4>
            <p>As a getter, the <b>.css()</b> method is valuable. However, it should generally be avoided as a setter in production-ready code, because it's generally best to keep presentational information out of JavaScript code. Instead, write CSS rules for classes that describe the various visual states, and then change the class on the element.</p>
            <code>
              // Working with classes.
         <br>
              var h1 = $( "h1" );
         <br>
              h1.addClass( "big" ); <br>
              h1.removeClass( "big" ); <br>
              h1.toggleClass( "big" ); <br>
         <br>
              if ( h1.hasClass( "big" ) ) {
         <br>
                            ...
        <br>
                            }
              </code>
            <h4>Dimensions</h4>
            <p>JQuery offers a variety of methods for obtaining and modifying dimension and position information about an element.</p>
        <p>The code below shows a brief overview of the dimensions functionality in jQuery. For complete details about jQuery dimension methods, visit the dimensions documentation on api.jquery.com.</p>
            <code>
              // Basic dimensions methods.
         <br><br>
              // Sets the width of all <b>h1</b> elements.
          <br>
                            $( "h1" ).width( "50px" );
         <br><br>
              // Gets the width of the first <b>h1</b> element.
        <br> 
                            $( "h1" ).width();
         <br><br>
              // Sets the height of all <b>h1</b> elements.
         <br>
                            $( "h1" ).height( "50px" );
         <br><br>
              // Gets the height of the first <b>h1</b> element.
         <br>
                            $( "h1" ).height();
         <br><br>
         
              // Returns an object containing position information for
           <br>
                            // the first <b>h1</b> relative to its "offset (positioned) parent".
          <br> 
                            $( "h1" ).position();
              </code>
          </article>
        </section>
            
            <section>
          <article id="link13" class="tab-content">
            <h3>Data Methods</h3>
            <p>There's often data about an element you want to store with the element. In plain JavaScript, you might do this by adding a property to the DOM element, but you'd have to deal with memory leaks in some browsers. jQuery offers a straightforward way to store data related to an element, and it manages the memory issues for you.</p>
            <code>
              // Storing and retrieving data related to an element.
         <br>
              $( "#myDiv" ).data( "keyName", { foo: "bar" } );
         <br>
              $( "#myDiv" ).data( "keyName" ); // Returns { foo: "bar" }
            </code>
            <p>Any kind of data can be stored on an element. For the purposes of this article, <b>.data()</b> will be used to store references to other elements.</p>
            <p>For example, you may want to establish a relationship between a list item and a <b>div</b> that's inside of it. This relationship could be established every single time the list item is touched, but a better solution would be to establish the relationship once, then store a pointer to the <b>div</b> on the list item using <b>.data()</b>:</p>
            <code>
              // Storing a relationship between elements using .data()
         <br>
             $( "#myList li" ).each(function() {
         <br>
             var li = $( this );
         <br>
                            var div = li.find( "div.content" );
         <br>
             li.data( "contentDiv", div );
         <br>
             });
         <br><br>
             // Later, we don't have to find the div again;
         <br>
                            // we can just read it from the list item's data
         <br>
                            var firstLi = $( "#myList li:first" );
         <br><br>
            firstLi.data( "contentDiv" ).html( "new content" );
              </code>
            <p>In addition to passing <b>.data()</b> a single key-value pair to store data, you can also pass an object containing one or more pairs.</p>
        
          </article>
        </section>
            
            <section>
          <article id="link14" class="tab-content">
            <h3>Utility Methods</h3>
            <p>jQuery offers several utility methods in the <b>$</b> namespace. These methods are helpful for accomplishing routine programming tasks. For a complete reference on jQuery utility methods, visit the utilities documentation on api.jquery.com. Below are examples of a few of the utility methods:</p>
            <p><b>$.trim()</b>:Removes leading and trailing whitespace</p>
            <p><b>$.each()</b>:The method <b>.each()</b> can be called on a selection to iterate over the elements contained in the selection. <b>.each()</b>, not <b>$.each()</b>, should be used for iterating over elements in a selection.</p>
            <p><b>$.inArray()</b>:Returns a value's index in an array, or -1 if the value is not in the array:</p>
            <code>
              var myArray = [ 1, 2, 3, 5 ];
         <br>
              if ( $.inArray( 4, myArray ) !== -1 ) {
         <br>
                            console.log( "found it!" );
        <br>
                            }
            </code>
          <p><b>$.extend()</b>:Changes the properties of the first object using the properties of subsequent objects</p>
            <p>If you don't want to change any of the objects you pass to <b>$.extend()</b>, pass an empty object as the first argument:</p>
            <code>
              var firstObject = { foo: "bar", a: "b" };
        <br>
                            var secondObject = { foo: "baz" };
         <br>
              var newObject = $.extend( {}, firstObject, secondObject );
         <br><br>
             console.log( firstObject.foo ); // "bar"
            <br>
                            console.log( newObject.foo ); // "baz"
              </code>
           <p><b>$.prroxy()</b>:Returns a function that will always run in the provided scope — that is, sets the meaning of this inside the passed function to the second argument.</p>
            <p>If you have an object with methods, you can pass the object and the name of a method to return a function that will always run in the scope of the object.</p>
            <h4>Testing Type</h4>
            <p>Sometimes the <b>typeof</b> operator can be confusing or inconsistent, so instead of using <b>typeof</b>, jQuery offers utility methods to help determine the type of a value.</p>
            <code>
              $.isArray([]); // true <br>
              $.isFunction(function() {}); // true <br>
              $.isNumeric(3.14); // true <br>
              </code>
            <p>Additionally, there is <b>$.type()</b> which checks for the internal class used to create a value. You can see the method as a better alternative for the <b>typeof</b> operator.</p>
           <code>
             $.type( true ); // "boolean" <br>
             $.type( 3 ); // "number" <br>
             $.type( "test" ); // "string" <br>
             $.type( function() {} ); // "function" <br>
         <br>
             $.type( new Boolean() ); // "boolean" <br>
             $.type( new Number(3) ); // "number" <br>
             $.type( new String('test') ); // "string" <br>
             $.type( new Function() ); // "function" <br>
         <br>
             $.type( [] ); // "array" <br>
             $.type( null ); // "null" <br>
             $.type( /test/ ); // "regexp" <br>
             $.type( new Date() ); // "date"
             </code>
          </article>
        </section>
            
            <section>
          <article id="link15" class="tab-content">
            <h3>Iterating Over JQuery And Non-JQuery Objects</h3>
            <p>jQuery provides an object iterator utility called <b>$.each()</b> as well as a jQuery collection iterator: <b>.each()</b>. These are not interchangeable. In addition, there are a couple of helpful methods called <b>$.map()</b> and <b>.map()</b> that can shortcut one of our common iteration use cases.</p>
         <p><b>$.each()</b> is a generic iterator function for looping over object, arrays, and array-like objects. Plain objects are iterated via their named properties while arrays and array-like objects are iterated via their indices.</p>
            <code>
            $.each( arr, function( index, value ){
        <br>
                            sum += value;
         <br>
                            });
         <br><br>
            console.log( sum ); // 15
            </code>
            <p>Notice that we don't have to access <b>arr[ index ]</b> as the value is conveniently passed to the callback in <b>$.each()</b>.</p>
            <p><b>.each()</b> is used directly on a jQuery collection. It iterates over each matched element in the collection and performs a callback on that object. The index of the current element within the collection is passed as an argument to the callback. The value (the DOM element in this case) is also passed, but the callback is fired within the context of the current matched element so the this keyword points to the current element as expected in other jQuery callbacks.</p>
            
            <h4>The Second Argument</h4>
            <p>The question is often raised, "If <b>this</b> is the element, why is there a second DOM element argument passed to the callback?"</p>
            <p>Whether intentional or inadvertent, the execution context may change. When consistently using the keyword <b>this</b>, it's easy to end up confusing ourselves or other developers reading the code. Even if the execution context remains the same, it may be more readable to use the second parameter as a named parameter. For example:</p>
            <code>
              $( "li" ).each( function( index, listItem ) {
         <br>
              this === listItem; // true
         <br>
              // For example only. You probably shouldn't call $.ajax() in a loop.
             <br>
                            $.ajax({
             <br>   
                            success: function( data ) {
            <br>
                            // The context has changed.
             <br> 
                            // The "this" keyword no longer refers to listItem.
            <br>
                            this !== listItem; // true
             <br>
                            }
                            <br>
              });
         <br>
              });
              </code>
        <p>The following is a list of methods that require <b>.each()</b>:</p>
            <ul>
          <li>.attr() (getter)</li>
          <li>.css() (getter)</li>
          <li>.data() (getter)</li>
          <li>.height() (getter)</li>
          <li>.html() (getter)</li>
          <li>.innerHeight()</li>
          <li>.innerWidth()</li>
          <li>.offset() (getter)</li>
          <li>.outerHeight()</li>
          <li>.outerWidth()</li>
          <li>.position()</li>
          <li>.prop() (getter)</li>
          <li>.scrollLeft() (getter)</li>
          <li>.scrollTop() (getter)</li>
          <li>.val() (getter)</li>
          <li>.width() (getter)</li>
            </ul>
          <p>Note that in most cases, the "getter" signature returns the result from the first element in a jQuery collection while the setter acts over the entire collection of matched elements. The exception to this is <b>.text()</b> where the getter signature will return a concatenated string of text from all matched elements.</p>
            <p>In addition to a setter value, the attribute, property, CSS setters, and DOM insertion "setter" methods (i.e. <b>.text()</b> and <b>.html()</b>) accept anonymous callback functions that are applied to each element in the matching set. The arguments passed to the callback are the index of the matched element within the set and the result of the 'getter' signature of the method.</p>
            <p>One other thing to keep in mind with this implicit iteration is that traversal methods such as <b>.children()</b> or <b>.parent()</b> will act on each matched element in a collection, returning a combined collection of all children or parent nodes.</p>
            <p><b>.map()</b>: There is a common iteration use case that can be better handled by using the <b>.map()</b> method. Anytime we want to create an array or concatenated string based on all matched elements in our jQuery selector, we're better served using <b>.map()</b>.</p>
            <p>Notice the <b>.get()</b> chained at the end. <b>.map()</b> actually returns a jQuery-wrapped collection, even if we return strings out of the callback. We need to use the argument-less version of <b>.get()</b> in order to return a basic JavaScript array that we can work with. To concatenate into a string, we can chain the plain JS <b>.join()</b> array method after <b>.get()</b>.</p>
            <p><b>$.map</b>: Like <b>$.each()</b> and <b>.each()</b>, there is a <b>$.map()</b> as well as <b>.map()</b>. The difference is also very similar to both <b>.each()</b> methods. <b>$.map()</b> works on plain JavaScript arrays while <b>.map()</b> works on jQuery element collections. Because it's working on a plain array, <b>$.map()</b> returns a plain array and <b>.get()</b> does not need to be called – in fact, it will throw an error as it's not a native JavaScript method.</p>
        <p>A word of warning: <b>$.map()</b> switches the order of callback arguments. This was done in order to match the native JavaScript <b>.map()</b> method made available in ECMAScript 5.</p>
            
          </article>
        </section>
        
            <section>
          <article id="link16" class="tab-content">
            <h3>Using jQuery’s .index() Function</h3>
            <p><b>.index()</b> is a method on jQuery objects that's generally used to search for a given element within the jQuery object that it's called on. This method has four different signatures with different semantics that can be confusing. This article covers details about how to understand the way <b>.index()</b> works with each signature.</p>
           <p>In this case, the DOM element that's passed into <b>.index()</b> is being checked against all of the elements in the original jQuery object. Once all other cases are understood, this should be the simplest case. It is very similar to the previous case, except since the DOM element is passed directly, it is not taken from a jQuery object container.</p>
        
            </article>
          </section>
            
        </div>
        
        
        <div class="reference">
          <h3>Reference</h3>
          <p>All the documentation in this page is taken from <a href="https://learn.jquery.com/" target="_blank">JQuery Learning Center</a>
            </p>
        </div>
    </body>
</html>
